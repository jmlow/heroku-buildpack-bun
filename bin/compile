#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-dir>

### Configure environment

set -o errexit  # always exit on error
set -o pipefail # don't ignore exit codes when piping output
unset GIT_DIR   # Avoid GIT_DIR leak from previous build steps

[[ -n ${BUILDPACK_XTRACE} ]] && set -o xtrace

### Constants

# This is used by the buildpack stdlib for metrics
# shellcheck disable=SC2034
BPLOG_PREFIX="buildpack.bun"

### Configure directories

BUILD_DIR=${1:-.}
CACHE_DIR=${2-}
ENV_DIR=${3-}
BP_DIR=$(
	cd "$(dirname "${0-}")"
	cd ..
	pwd
)

### Load dependencies

# shellcheck source=lib/vendor/stdlib_v7.sh
source "${BP_DIR}/lib/vendor/stdlib_v7.sh"
# shellcheck source=lib/output.sh
source "${BP_DIR}/lib/output.sh"
# shellcheck source=lib/monitor.sh
source "${BP_DIR}/lib/monitor.sh"
# shellcheck source=lib/environment.sh
source "${BP_DIR}/lib/environment.sh"
# shellcheck source=lib/failure.sh
source "${BP_DIR}/lib/failure.sh"
# shellcheck source=lib/binaries.sh
source "${BP_DIR}/lib/binaries.sh"
# shellcheck source=lib/json.sh
source "${BP_DIR}/lib/json.sh"
# shellcheck source=lib/cache.sh
source "${BP_DIR}/lib/cache.sh"
# shellcheck source=lib/dependencies.sh
source "${BP_DIR}/lib/dependencies.sh"
# shellcheck source=lib/plugin.sh
source "${BP_DIR}/lib/plugin.sh"
# shellcheck source=lib/uuid.sh
source "${BP_DIR}/lib/uuid.sh"
# shellcheck source=lib/kvstore.sh
source "${BP_DIR}/lib/kvstore.sh"
# shellcheck source=lib/metadata.sh
source "${BP_DIR}/lib/metadata.sh"
# shellcheck source=lib/builddata.sh
source "${BP_DIR}/lib/builddata.sh"

export PATH="${BUILD_DIR}/.heroku/bun/bin:${PATH}"

LOG_FILE=$(mktemp -t bun-build-log.XXXXX)
echo "" >"${LOG_FILE}"

build_start_time=$(nowms)

### Handle errors

handle_failure() {
	meta_set "bun-build-success" "false"
	header "Build failed"
	fail_invalid_semver "${LOG_FILE}"
	log_other_failures "${LOG_FILE}"
	warn_missing_devdeps "${LOG_FILE}" "${BUILD_DIR}"
	log_meta_data >>"${BUILDPACK_LOG_FILE}"
	failure_message | output "${LOG_FILE}"
}
trap 'handle_failure' ERR

### Initalize metadata store
# Create the metadata store
meta_init "${CACHE_DIR}"
# Make sure that it's empty and save any previous build's data
meta_setup
# the "build-step" key keeps track of where we are in the execution
# so that we can see where failed builds errored
meta_set "build-step" "init"

### Check initial state

[[ -e "${BUILD_DIR}/node_modules" ]] && PREBUILD=true || PREBUILD=false

### Save build info
log_initial_state
generate_uuids

### Failures that should be caught immediately

fail_dot_heroku "${BUILD_DIR}"
fail_invalid_package_json "${BUILD_DIR}"
warn_prebuilt_modules "${BUILD_DIR}"
warn_missing_package_json "${BUILD_DIR}"

### Gather more project information

# we know that package.json is valid json, and can pull more data out
log_project_info "${BUILD_DIR}"

### Compile

create_env() {
	export_env_dir "${ENV_DIR}"
	create_default_env
	write_profile "${BP_DIR}" "${BUILD_DIR}"
	write_export "${BP_DIR}" "${BUILD_DIR}"
}

header "Creating runtime environment" | output "${LOG_FILE}"

mkdir -p "${BUILD_DIR}/.heroku/bun/"
cd "${BUILD_DIR}"
create_env # can't pipe the whole thing because piping causes subshells, preventing exports
list_bun_config | output "${LOG_FILE}"

### Configure package manager cache directories
[[ -z ${BUN_CACHE_FOLDER} ]] && BUN_CACHE_FOLDER=$(mktemp -d -t buncache.XXXXX)
export BUN_CACHE_FOLDER

install_bins() {
	local bun_engine bun_version package_manager

	bun_engine=$(read_json "${BUILD_DIR}/package.json" ".engines.bun")
	package_manager=$(read_json "${BUILD_DIR}/package.json" ".packageManager")

	meta_set "bun-version-request" "${bun_engine}"
	meta_set "package-manager-request" "${package_manager}"

	echo "engines.bun (package.json):   ${bun_engine:-unspecified}"

	[[ -n ${package_manager} ]] && echo "packageManager (package.json): $(echo "${package_manager}" | cut -d "+" -f 1)"

	echo ""

	meta_set "build-step" "install-bun"
	monitor "install-bun-binary" install_bun "${bun_engine}" "${BUILD_DIR}/.heroku/bun"

	bun_version="$(bun --version)"
	mcount "version.bun.${bun_version}"
	meta_set "bun-version" "${bun_version}"
}

header "Installing binaries" | output "${LOG_FILE}"
install_bins | output "${LOG_FILE}"

restore_cache() {
	local cache_status cache_directories restore_cache_start_time
	restore_cache_start_time=$(nowms)

	cache_status="$(get_cache_status "${CACHE_DIR}")"
	cache_directories="$(get_cache_directories "${BUILD_DIR}")"

	if ${PREBUILD}; then
		if [[ ${BUN_SKIP_MODULES_CHECK} == "true" ]]; then
			echo "Keeping existing node_modules because BUN_SKIP_MODULES_CHECK=${BUN_SKIP_MODULES_CHECK}"
		else
			warn "node_modules checked into source control" "https://devcenter.heroku.com/articles/node-best-practices#only-git-the-important-bits"
			rm -rf "${BUILD_DIR}/node_modules"
		fi
	fi

	if [[ ${cache_status} == "disabled" ]]; then
		header "Restoring cache"
		echo "Caching has been disabled because BUN_MODULES_CACHE=${BUN_MODULES_CACHE}"
	elif [[ ${cache_status} == "valid" ]]; then
		header "Restoring cache"
		if [[ ${cache_directories} == "" ]]; then
			restore_default_cache_directories "${BUILD_DIR}" "${CACHE_DIR}" "${BUN_CACHE_FOLDER}"
		else
			restore_custom_cache_directories "${BUILD_DIR}" "${CACHE_DIR}" "${cache_directories}"
		fi
	elif [[ ${cache_status} == "new-signature" ]]; then
		header "Restoring cache"
		if [[ ${cache_directories} == "" ]]; then
			echo "Cached directories were not restored due to a change in version of bun or stack"
			echo "Module installation may take longer for this build"
		else
			# If the user has specified custom cache directories, be more explicit
			echo "Invalidating cache due to a change in version of bun or stack"
			echo "Will not restore the following directories for this build:"
			for directory in ${cache_directories}; do
				echo "  ${directory}"
			done
		fi
	else
		# No cache exists, be silent
		:
	fi

	mcount "cache.${cache_status}"
	meta_set "cache-status" "${cache_status}"
	meta_time "restore-cache-time" "${restore_cache_start_time}"
}

meta_set "build-step" "restore-cache"
restore_cache | output "${LOG_FILE}"

build_dependencies() {
	local cache_status start
	local has_bun_lock has_bun_engine has_bun_package_manager

	cache_status="$(get_cache_status "${CACHE_DIR}")"
	start=$(nowms)

	if [[ -f "${BUILD_DIR}/package.json" ]]; then
		[[ -f "${BUILD_DIR}/bun.lockb" ]] && has_bun_lock=true || has_bun_lock=false
		local bun_engine
		bun_engine=$(read_json "${BUILD_DIR}/package.json" ".engines.bun")
		[[ -n ${bun_engine} ]] && has_bun_engine=true || has_bun_engine=false

		local package_manager package_manager_check
		package_manager=$(read_json "${BUILD_DIR}/package.json" ".packageManager")
		package_manager_check=$(echo "${package_manager}" | grep "^bun@" || true)
		[[ -n ${package_manager_check} ]] && has_bun_package_manager=true || has_bun_package_manager=false

		if ${has_bun_lock}; then
			echo "Bun lockfile (bun.lockb) detected"
		fi
		if ${has_bun_engine}; then
			echo "Bun version specified in engines"
		fi
		if ${has_bun_package_manager}; then
			echo "Bun specified as package manager"
		fi

		local dependencies
		dependencies=$(read_json "${BUILD_DIR}/package.json" '.dependencies')
		if [[ -n ${dependencies} ]]; then
			echo "Installing dependencies with Bun"
			bun_install "${BUILD_DIR}"
		else
			echo "No dependencies found in package.json"
		fi
	fi

	mtime "modules.time.cache.${cache_status}" "${start}"

	meta_set "build-step" "build-script"
	header "Build"
	run_build_script "${BUILD_DIR}"
}

meta_set "build-step" "install-dependencies"
run_prebuild_script "${BUILD_DIR}" | output "${LOG_FILE}"
header "Installing dependencies" | output "${LOG_FILE}"
build_dependencies | output "${LOG_FILE}"

cache_build() {
	local cache_directories cache_build_start_time
	cache_build_start_time=$(nowms)
	cache_directories="$(get_cache_directories "${BUILD_DIR}")"

	clear_cache "${CACHE_DIR}"
	if ! ${BUN_MODULES_CACHE:-true}; then
		# we've already warned that caching is disabled in the restore step
		# so be silent here
		:
	elif [[ ${cache_directories} == "" ]]; then
		header "Caching build"
		save_default_cache_directories "${BUILD_DIR}" "${CACHE_DIR}" "${BUN_CACHE_FOLDER}"
	else
		header "Caching build"
		save_custom_cache_directories "${BUILD_DIR}" "${CACHE_DIR}" "${cache_directories}"
	fi
	save_signature "${CACHE_DIR}"
	meta_time "save-cache-time" "${cache_build_start_time}"
}

meta_set "build-step" "save-cache"
cache_build | output "${LOG_FILE}"

meta_set "build-step" "prune-dependencies"
header "Pruning devDependencies" | output "${LOG_FILE}"
bun_prune_devdependencies "${BUILD_DIR}" | output "${LOG_FILE}"

meta_set "build-step" "cleanup-script"
run_cleanup_script "${BUILD_DIR}" | output "${LOG_FILE}"

summarize_build() {
	if ${NODE_VERBOSE}; then
		list_dependencies "${BUILD_DIR}"
	fi

	mmeasure 'modules.size' "$(measure_size)"
	meta_set "node-modules-size" "$(measure_size)"
}

meta_set "build-step" "install-metrics-plugin"
install_plugin "${BP_DIR}" "${BUILD_DIR}"

meta_set "build-step" "summarize"
header "Build succeeded!" | output "${LOG_FILE}"
mcount "compile"
summarize_build | output "${LOG_FILE}"
meta_set "bun-build-success" "true"
meta_time "build-time" "${build_start_time}"

warn_no_start "${BUILD_DIR}"
warn_unmet_dep "${LOG_FILE}"

meta_set "build-step" "finished"
log_meta_data >>"${BUILDPACK_LOG_FILE}"
